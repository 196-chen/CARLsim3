/*
 * Copyright (c) 2013 Regents of the University of California. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. The names of its contributors may not be used to endorse or promote
 *    products derived from this software without specific prior written
 *    permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * *********************************************************************************************** *
 * CARLsim
 * created by: 		(MDR) Micah Richert, (JN) Jayram M. Nageswaran
 * maintained by:	(MA) Mike Avery <averym@uci.edu>, (MB) Michael Beyeler <mbeyeler@uci.edu>,
 *					(KDC) Kristofor Carlson <kdcarlso@uci.edu>
 *					(TSC) Ting-Shuo Chou <tingshuc@uci.edu>
 *
 * CARLsim available from http://socsci.uci.edu/~jkrichma/CARL/CARLsim/
 * Ver 10/09/2013
 */ 

#include "snn.h"

class SpikeController: public SpikeMonitor, SpikeGenerator {
private:
	FILE* fid;
	unsigned int controllerCurrentTime;

public:
	SpikeController(FILE* _fid) {
		fid = _fid;
		controllerCurrentTime = 0;
	}

	// nextSpikeTime is called every one second (1000 ms)
	unsigned int nextSpikeTime(CpuSNN* s, int grpId, int nid, unsigned int currentTime, unsigned int lastScheduledSpikeTime) {
		return 0xFFFFFFFF;
	}

	void update(CpuSNN* s, int grpId, unsigned int* Nids, unsigned int* timeCnts)
	{
		int pos = 0;
		int lastPreSpikeTime = -21;
		int lastPostSpikeTime = -21;

		for (int t = 0; t < 1000; t++) {
			for(int i = 0; i < timeCnts[t]; i++, pos++) {
				int time = t + s->getSimTime() - 1000;
				int id = Nids[pos];
				//int cnt = fwrite(&time, sizeof(int), 1, fid);
				//assert(cnt != 0);
				//cnt = fwrite(&id, sizeof(int), 1, fid);
				//assert(cnt != 0);
			}

			
		}

		fflush(fid);
	}
};

// Version 1.0
// Dopamine-signaled reward predictions generated by comptetive excitation and inhibition in a spiking neural network model
int main()
{
	// create a network
	CpuSNN* s;
	SpikeController* spikeCtrl;
	FILE* stdpLog;
	int pfc, sen_cs, sen_us, ic_cs, ic_us, str, da;
	int pfc_input, sen_cs_input, sen_us_input;
	
	stdpLog = fopen("STDP.txt", "wb");

	s = new CpuSNN("global", GPU_MODE);
	spikeCtrl = new SpikeController(stdpLog);

	//daController = new DopamineController(stdpLog);

	pfc = s->createGroup("PFC_Ex", 1000, EXCITATORY_NEURON);
	s->setNeuronParameters(pfc, 0.02f, 0.2f, -65.0f, 8.0f);

	//int g2 = s->createGroup("inhib", N * 0.2, INHIBITORY_NEURON);
	//s->setNeuronParameters(g2, 0.1f,  0.2f, -65.0f, 2.0f);

	// sensory neurons
	sen_cs = s->createGroup("Sensory_CS", 50, EXCITATORY_NEURON);
	s->setNeuronParameters(sen_cs, 0.02f, 0.2f, -65.0f, 8.0f);

	sen_us = s->createGroup("Sensory_US", 50, EXCITATORY_NEURON);
	s->setNeuronParameters(sen_us, 0.02f, 0.2f, -65.0f, 8.0f);

	// ic neurons
	ic_cs = s->createGroup("Insular_CS", 50, EXCITATORY_NEURON);
	s->setNeuronParameters(ic_cs, 0.02f, 0.2f, -65.0f, 8.0f);

	ic_us = s->createGroup("Insular_US", 50, EXCITATORY_NEURON);
	s->setNeuronParameters(ic_us, 0.02f, 0.2f, -65.0f, 8.0f);

	// 100 striatum neurons
	str = s->createGroup("Stritum", 100, INHIBITORY_NEURON);
	s->setNeuronParameters(str, 0.02f, 0.2f, -65.0f, 8.0f);
	
	// 100 dopaminergeic neurons
	da = s->createGroup("Dopaminergic Area", 100, DOPAMINERGIC_NEURON);
	s->setNeuronParameters(da, 0.02f, 0.2f, -65.0f, 8.0f);

	// stimulus 
	pfc_input = s->createSpikeGeneratorGroup("PFC input", 1000, EXCITATORY_NEURON);
	sen_cs_input = s->createSpikeGeneratorGroup("Sensory_CS input", 50, EXCITATORY_NEURON);
	sen_us_input = s->createSpikeGeneratorGroup("Sensory_US input", 50, EXCITATORY_NEURON);


	s->setWeightUpdateParameter(_10MS, 100);

	// make random connections with 10% probability
	//s->connect(g2, g1, "random", -4.0f/100, -4.0f/100, 0.1f, 1, 1, SYN_FIXED);
	// make random connections with 10% probability, and random delays between 1 and 20
	//s->connect(g1, g2, "random", 5.0f/100, 10.0f/100, 0.1f,  1, 20, SYN_PLASTIC);
	
	s->connect(pfc, str, "random", 2.5f/100, 10.0f/100, 0.1f,  1, 20, SYN_PLASTIC);

	s->connect(sen_cs, ic_cs, "full", 4.0f/100, 10.0f/100, 1.0f, 1, 20, SYN_PLASTIC);
	s->connect(sen_us, ic_us, "full", 4.0f/100, 10.0f/100, 1.0f, 1, 20, SYN_PLASTIC);

	s->connect(str, da, "full", -0.5f/100, -0.5f/100, 1.0f, 1, 10, SYN_FIXED);

	s->connect(ic_cs, da, "full", 1.0f/100, 1.0f/100, 1.0f, 1, 10, SYN_FIXED);
	s->connect(ic_us, da, "full", 1.0f/100, 1.0f/100, 1.0f, 1, 10, SYN_FIXED);

	// 5% probability of connection
	// Dummy synaptic weights. Dopaminergic neurons only release dopamine to the target area in the current model.
	s->connect(da, str, "random", 0.0, 0.0, 0.05f, 10, 20, SYN_FIXED);
	s->connect(da, ic_cs, "random", 0.0, 0.0, 0.05f, 10, 20, SYN_FIXED);
	s->connect(da, ic_us, "random", 0.0, 0.0, 0.05f, 10, 20, SYN_FIXED);

	// input connection
	s->connect(pfc_input, pfc, "one-to-one", 20.0f/100, 20.0f/100, 1.0f,  1, 1, SYN_FIXED);
	s->connect(sen_cs_input, sen_cs, "one-to-one", 20.0f/100, 20.0f/100, 1.0f, 1, 1, SYN_FIXED);
	s->connect(sen_us_input, sen_us, "one-to-one", 20.0f/100, 20.0f/100, 1.0f, 1, 1, SYN_FIXED);

	float COND_tAMPA=5.0, COND_tNMDA=150.0, COND_tGABAa=6.0, COND_tGABAb=150.0;
	s->setConductances(ALL,true,COND_tAMPA,COND_tNMDA,COND_tGABAa,COND_tGABAb);

	// here we define and set the properties of the STDP. 
	float ALPHA_LTP = 0.10f/100, TAU_LTP = 20.0f, ALPHA_LTD = 0.08f/100, TAU_LTD = 40.0f;	
	s->setSTDP(str, true, true, ALPHA_LTP, TAU_LTP, ALPHA_LTD, TAU_LTD);
	s->setSTDP(ic_cs, true, true, ALPHA_LTP, TAU_LTP, ALPHA_LTD, TAU_LTD);
	s->setSTDP(ic_us, true, true, ALPHA_LTP, TAU_LTP, ALPHA_LTD, TAU_LTD);

	// show logout every 10 secs, enabled with level 1 and output to stdout.
	s->setLogCycle(10, 3, stdout);

	// put spike times into spikes.dat
	//s->setSpikeMonitor(g1,"spikes.dat");
	s->setSpikeMonitor(pfc);
	s->setSpikeMonitor(sen_cs);
	s->setSpikeMonitor(sen_us);
	s->setSpikeMonitor(ic_cs);
	s->setSpikeMonitor(ic_us);
	s->setSpikeMonitor(str);
	s->setSpikeMonitor(da);

	//setup random thalamic noise
	PoissonRate pfc_input_rate(1000);
	for (int i = 0; i < 1000; i++)
		pfc_input_rate.rates[i] = 1.0;
	s->setSpikeRate(pfc_input, &pfc_input_rate);

	PoissonRate sen_input_rate(50);
	for (int i = 0; i < 50; i++)
		sen_input_rate.rates[i] = 1.0;
	s->setSpikeRate(sen_cs_input, &sen_input_rate);
	s->setSpikeRate(sen_us_input, &sen_input_rate);

	//s->setSpikeGenerator(pfc_input, (SpikeGenerator*)spikeCtrl);
	//s->setSpikeGenerator(sen_cs_input, (SpikeGenerator*)spikeCtrl);
	//s->setSpikeGenerator(sen_us_input, (SpikeGenerator*)spikeCtrl);

	
	//run for 60 seconds
	for(int i = 0; i < 10; i++) {
		// run the established network for a duration of 1 (sec)  and 0 (millisecond), in CPU_MODE
		s->runNetwork(1, 0);
	}

	FILE* nid = fopen("network.dat","wb");
	s->writeNetwork(nid);
	fclose(nid);

	fclose(stdpLog);

	delete s;
	delete spikeCtrl;

	return 0;
}

