/*!

\page tut1_basic_concepts Tutorial 1: Basic Concepts
\tableofcontents

\author Michael Beyeler
\see \ref ch1_getting_started
\see \ref ch2_basic_concepts
\see \ref ch3_neurons_synapses_groups
\see \ref ch4_connections
\see \ref ch9_matlab_oat


In this tutorial we will implement one of the smallest functional CARLsim simulations,
consisting of a Poisson spike generator connected to an Izhikevich neuron with a single fixed
(non-plastic) synapse.
We will run the network for a total of ten seconds, during which time the firing activity
of the Izhikevich neuron will be recorded and dumped to file.
We will then visualize the firing activity using a GroupMonitor from the MATLAB Offline
Analysis Toolbox (OAT).

At the end of the tutorial, you will know how to:
- import the CARLsim library and instantiate the simulation object
- create groups of neurons
- specify the network structure by connecting neurons
- run a network on the CPU and GPU
- use a GroupMonitor to visualize neuronal activity (OAT)

This tutorial assumes you know:
- the very basics of C/C++
- the Izhikevich neuron model
- how to install CARLsim

The source code of this tutorial can be found in <tt>%%%CARLSIM_ROOT_DIR%%/doc/source/tutorial/1_basic_concepts</tt>.


\section tut1s1_simple_prog 1.1 A Simple CARLsim program

The smallest functional CARLsim network contains just two neurons, connected with a single synapse.

After successful installation, the first step in setting up a CARLsim program is to include the
<tt>libCARLsim</tt> library and to instantiate the main simulation object:
\code
#include <carlsim.h>
#include <stdio.h>

int main(int argc, const char* argv[]) {
	// ---------------- CONFIG STATE -------------------
	CARLsim sim("basics", CPU_MODE, USER);
\endcode

This prepares the simulation for execution in either ::CPU_MODE or ::GPU_MODE,
and specifies the verbosity of the status reporting mechanism,
where ::USER indicates the default logger mode that will print info and error messages to console and
save debug messages in a text file.
By default, this file is called <tt>"carlsim.log"</tt> and can be found in the <tt>"results/"</tt> subdirectory.

Running a simulation on the GPU is as easy as replacing ::CPU_MODE with ::GPU_MODE in the above code.
No other adjustments are necessary.
However, it is possible to pass an additional input argument <tt>ithGPU</tt> to specify the device index
(on which GPU to run in a multi-GPU system).


\subsection tut1s1s1_config 1.1.1 CONFIG State

From then on, the simulation is in ::CONFIG_STATE, allowing the properties of the neural network to be specified.
In this tutorial, we consider a network with two neuronal groups, each of which contains a single neuron.

A SpikeGenerator group is created by specifying a name for the group (<tt>"input"</tt>), the number of neurons
in the group (just one), and a type (::EXCITATORY_NEURON):
\code
	int gIn = sim.createSpikeGeneratorGroup("input", nNeur, EXCITATORY_NEURON);
\endcode
To refer to this group in later method calls, a group ID is returned (<tt>gIn</tt>).
A SpikeGenerator is different from an Izhikevich neuron in that it does not provide a differential equation of
its membrane potential; instead it only contains a list of spike times.

Similarly, a group of Izhikevich spiking neurons can be created by specifying a name for the group (<tt>"output"</tt>),
the number of neurons in the group (again just one), and a type (::EXCITATORY_NEURON).
However, in contrast to the SpikeGenerator group, we also need to specify the Izhikevich parameters a, b, c, and d.
These two things can be achieved with the following code snippet:
\code
	int gOut = sim.createGroup("output", nNeur, EXCITATORY_NEURON);
	sim.setNeuronParameters(gOut, 0.02f, 0.2f, -65.0f, 8.0f); // RS
\endcode
where we use the ID <tt>gOut</tt> to refer to the group, and set <tt>a=0.02f</tt>, <tt>b=0.2f</tt>,
<tt>c=-65.0f</tt>, and <tt>d=8.0f</tt> (regular spiking).

Then the synaptic connections can be specified.
The two groups are connected with the <tt>"one-to-one"</tt> primitive type of CARLsim::connect that connects
neuron i in the pre-synaptic group to neuron i in the post-synaptic group (both groups must have the same number
of neurons):
\code
	// connect input to output group
	sim.connect(gIn, gOut, "one-to-one", RangeWeight(0.05f), 1.0f);
\endcode
where we initialize and fixate the weight magnitude at <tt>0.05f</tt> and set the connection probability to
<tt>1.0f</tt> (100%).
We use default values for the other input arguments (1 ms axonal delay, no particular spatial receptive field,
and a non-plastic synapse type, ::SYN_FIXED).

As a side note: Since there is only one neuron in each group, <tt>"one-to-one"</tt> connectivity would have the same effect as
<tt>"full"</tt> connectivity or <tt>"random"</tt> connectivity with 100% connection probability.

Finally, we enable synaptic conductances so that the network is run in COBA mode (see \ref ch3s2s2_coba):
\code
	// enable COBA mode
	sim.setConductances(true);
\endcode


\subsection tut1s1s2_setup 1.1.2 SETUP State

Once the spiking network has been specified, the function CARLsim::setupNetwork optimizes the network state for the
chosen back-end (CPU or GPU) and moves the simulation into ::SETUP_STATE:
\code
	// ---------------- SETUP STATE -------------------
	sim.setupNetwork();
\endcode

In this state, we specify a SpikeMonitor object to record network activity
to a <tt>"DEFAULT"</tt> binary file (see \ref ch7_monitoring):
\code
	sim.setSpikeMonitor(gOut, "DEFAULT");
\endcode
This will dump all spikes of group <tt>gOut</tt> (in AER format) to a binary with default file name
<tt>"results/spk_output.dat"</tt>, where <tt>"output"</tt> is the name that was assigned to the group <tt>gOut</tt>
in the call to CARLsim::createGroup above.


\subsection tut1s1s3_run 1.1.3 RUN State

The first call to CARLsim::runNetwork will take the simulation into ::RUN_STATE.

We will run a simulation for a total of ten seconds, during which the firing activity of group <tt>gOut</tt>
will be recorded by using the SpikeMonitor set above.

At the beginning of the simulation, the spike generator group <tt>gIn</tt> will generate Poisson spike trains
with 10Hz mean firing rate, but this number will be gradually increased every second until it reaches 100Hz.
\code
	int nNeur = 1; 				// number of neurons in each group
	PoissonRate in(nNeur);		// PoissonRate containter for SpikeGenerator group

	// ...

	// run the network repeatedly for 1 second (1*1000 + 0 ms)
	// with different Poisson input
	for (int i=1; i<=10; i++) {
		float inputRateHz = i*10.0f;
		in.setRates(inputRateHz);

		// run for 1 second
		sim.runNetwork(1,0);
	}
\endcode


\section tut1s2_network_output 1.2 Network Output

Every second, we will gradually increase the mean firing rate of the Poisson spike generator group <tt>gIn</tt>,
starting at 10 Hz and ending at 100 Hz.
The simulation will be repeatedly run (or "stepped") for 1ms, up to the point at which a total of 10,000ms are
simulated. After every 1,000ms

\image html 1_gm_raster.jpg "Fig. 1. GroupMonitor output (raster plot)"

\image html 1_ffcurve.jpg "Fig. 2. Input-output curve (FF curve)"




The main simulation loop is encapsulated by a pair of SpikeMonitor::startRecording and SpikeMonitor::stopRecording
calls, which instruct the SpikeMonitor objects to keep track of all spikes emitted by the neurons in their monitored
group (see \ref ch7s1s2s1_start_stop_recording):
\code
	// ---------------- RUN STATE -------------------
	SMexc->startRecording();
	SMinh->startRecording();
	for (int t=0; t<10000; t++) {
		// main simulation loop
		// etc.
	}
	SMexc->stopRecording();
	SMinh->stopRecording();
\endcode

After (or during) the simulation these objects could be queried for more detailed spike metrics
(see \ref ch7s1s2s3_spike_metrics), but for the sake of simplicity we will only print a condensed version of
spike statistics at the end:
\code
	// print firing stats (but not the exact spike times)
	SMexc->print(false);
	SMinh->print(false);
\endcode

Finally, the main simulation loop consists of repeatedly stepping the model for 1ms.
At every step we randomly choose a single neuron in the network to receive an external (thalamic) input current
of <tt>20.0f</tt>.
To achieve this, we maintain a vector of external currents for every neuron in the group, initialized to zero:
\code
		// random thalamic input to a single neuron from either gExc or gInh
		std::vector<float> thalamCurrExc(nNeurExc, 0.0f);
		std::vector<float> thalamCurrInh(nNeurInh, 0.0f);
\endcode



The objective of this tutorial is to hook up a Poisson spike generator to a single Izhikevich neuron and look
at the output activity.

CARLsim is broken into 3 different states: ::CONFIG_STATE, ::SETUP_STATE, and ::RUN_STATE.

Before we discuss code in each state, note that we have included the <tt>carlsim.h</tt> header file, which is
required for every CARLsim simulation.

\code
#include <carlsim.h>
\endcode

Inside the main function we have the following. First we begin with the ::CONFIG_STATE state code. Here we
create a CARLsim object named "Hello World"  that runs on the CPU and outputs data to the console in
USER mode. Next, we create a Poisson Group named "input" with 1 neuron in the group and create a
single regular spiking (RS) izhikevich neuron named "output". We set the neuron parameters with a
call to setNeuronParameters. Additionally, we give the output neuron NMDA and AMPA conductances by
setting conductances to be true. Finally we connect the input neuron to the output neuron with a
weight of 0.1 and a delay of 1.

\code
	// ---------------- CONFIG STATE -------------------
	CARLsim sim("Hello World", CPU_MODE, USER);
	int gIn = sim.createSpikeGeneratorGroup("input", 1, EXCITATORY_NEURON);
	int gOut = sim.createGroup("output", 1, EXCITATORY_NEURON);
	sim.setNeuronParameters(gOut, 0.02f, 0.2f, -65.0f, 8.0f);
	sim.setConductances(true);
	// connect our groups
	sim.connect(gIn, gOut, "one-to-one", RangeWeight(0.05f), 1.0f);
\endcode

A call to CARLsim::setupNetwork takes the simulation from ::CONFIG_STATE to ::SETUP_STATE.
This must be done before CARLsim::runNetwork can be called.
In the setup state we create a SpikeMonitor object to monitor spike data from the output neuron.

\code
	// ---------------- SETUP STATE -------------------
	sim.setupNetwork();
	sim.setSpikeMonitor(gOut,"DEFAULT");
\endcode

Finally, the first call to CARLsim::runNetwork will take the simulation to ::RUN_STATE.
Set the firing rate rate of the input neuron to 20 Hz and run the network for 10 seconds:
\code
	// ---------------- RUN STATE -------------------
	PoissonRate in(1);
	in.setRates(20.0f);
	sim.setSpikeRate(gIn, &in);
	sim.runNetwork(10,0);
\endcode


\section tut1s2_output 1.2 CARLsim Output

After navigating to <tt>%%CARLSIM_ROOT_DIR%%/doc/source/tutorial/1_basic_concepts</tt>, the network can be
compiled and run with the following commands (on Linux):
\code
$ make
$ ./basic_concepts
\endcode
On Windows, the <tt>.vcxproj</tt> file is already added to the <tt>CARLsim.sln</tt> solution file.
Thus the project can be built simply by opening the solution file in Visual Studio, by right-clicking the
project directory and choosing "Build project".

Some of the CARLsim console output is shown below:

\code
*****************      Initializing CPU Simulation      *************************
SpikeMonitor set for group 1 (output)

* *******************      Running CPU Simulation      ***************************

(t=10.000s) SpikeMonitor for group output(1) has 22 spikes in 1000ms (22.00 +/- 0.00 Hz)


* *******************      CPU Simulation Summary      ***************************
Network Parameters: 	numNeurons = 2 (numNExcReg:numNInhReg = 50.0:0.0)
			numSynapses = 1
			maxDelay = 1
Simulation Mode:	COBA
Random Seed:		1423948616
Timing:			Model Simulation Time = 10 sec
			Actual Execution Time = 0.00 sec
Average Firing Rate:	2+ms delay = 0.000 Hz
			1ms delay = inf Hz
			Overall = 11.850 Hz
Overall Firing Count:	2+ms delay = 0
			1ms delay = 237
			Total = 237
* ********************************************************************************
\endcode

The SpikeMonitor reports it has run for 10 seconds and recorded 22 spikes in most recent 1000 ms for
an average firing rate of 22 Hz (since there is only one neuron in the group).

Additionally, spike files and log files have been written to the results folder and can be easily
visualized with the offline analysis toolbox (see \ref ch9_matlab_oat).

*/
