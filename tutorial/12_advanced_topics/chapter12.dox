/*!

\page ch12_advanced_topics Chapter 12: Advanced Topics

\tableofcontents



\section ch12s1_best_practices 12.1 Best Practices


\subsection ch12s1s1_tips_tricks 12.1.1 Tips and Tricks, Do's and Don'ts

Don't record all spikes forever. Tricks for doing training and testing.


\subsection ch12s1s2_speed_up 12.1.2 Ways to Speed Up Your Simulation

Don't record all spikes forever. Silent mode. Cost of using certain functions. Handling large-scale networks.

\see \ref ch7s1_spike_monitor
\see \ref ch12s4_logging_errors


\section ch12s2_multi_gpu 12.2 Multi-GPU

Use threading to create a CARLsim simulation on every GPU. Say in the future we'll have a more advanced way of doing that.



\section ch12s3_online_weight_tuning 12.3 On-Line Weight Tuning

CARLsim provides a range of handy functions to change weight values on the fly; that is, without having to recompile
the network.
The function CARLsim::setWeight allows a user to change the weight of a single synapse.
Alternatively, CARLsim::biasWeights can be used to add a constant bias to every weight of a certain connection ID,
and CARLsim::scaleWeigths multiplies all the weights with a scaling factor.

These functions are useful especially for tuning feedforward weights in large-scale networks that would otherwise take
a lot of time to repeatedly build.
For tuning in more complex situations please refer to \ref ch10_ecj.

These functions are only valid in ::carlsimState_t <tt>EXE_STATE</tt> and do not alter the topography of the network.
They apply to weight values of already allocated synapses only.

\see \ref ch10_ecj


\subsection ch12s3s1_set_weight 12.3.1 Setting the Weight of a Single Synapse

The easiest way to change the weight of a synapse is CARLsim::setWeight:
\code
// must be in EXECUTION state
sim.runNetwork(1,0);

// remember connId from connect call
// change the weight from first pre-neuron to fifth post-neuron to 0.25f
// make sure this synapse this allocated!
sim.setWeight(connId, 0, 4, 0.25f);
\endcode
This function will set the weight of a particular synapse of connection ID <tt>connId</tt>, namely
the synapse connecting neuron <tt>neurIdPre</tt> to neuron <tt>neurIdPost</tt>, to value <tt>weight</tt>.
Here, the connection ID is the return argument of the corresponding CARLsim::connect call.
Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.

If the specified weight lies outside the boundaries <tt>[minWt,maxWt]</tt> of RangeWeight, then two different behaviors
can be achieved, depending on a fifth optional argument <tt>updateWeightRange</tt>.
- If <tt>updateWeightRange</tt> is set to <tt>true</tt>, then the corresponding weight boundaries <tt>[minWt,maxWt]</tt>
  will be updated should the specified weight lie outside those boundaries.
- If <tt>updateWeightRange</tt> is set to <tt>false</tt>, then the corresponding weight will be clipped so that it stays
  within the existing weight boundaries <tt>[minWt,maxWt]</tt>.

\attention Make sure this function is called on a synapse that actually exists!
\since v3.0


\subsection ch12s3s2_bias_weights 12.3.2 Add a Bias to All the Weights of a Connection

Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID
using CARLsim::biasWeights:
\code
// must be in EXECUTION state
sim.runNetwork(1,0);

// remember connId from connect call
// add 0.125 to all allocated synapses of connId
// set updateWeightRange flag to true in order to update [minWt,maxWt] if necessary
sim.biasWeights(connId, 0.125f, true);
\endcode
This function will add a constant <tt>bias</tt> to the weight of every synapse of connection ID <tt>connId</tt>.
Here, the connection ID is the return argument of the corresponding CARLsim::connect call.
Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.

If the new weight (old weight plus bias) lies outside the boundaries <tt>[minWt,maxWt]</tt> of RangeWeight, then two
different behaviors can be achieved, depending on a third optional argument <tt>updateWeightRange</tt>.
- If <tt>updateWeightRange</tt> is set to <tt>true</tt>, then the corresponding weight boundaries <tt>[minWt,maxWt]</tt>
  will be updated should the new weight lie outside those boundaries.
- If <tt>updateWeightRange</tt> is set to <tt>false</tt>, then the corresponding weight will be clipped so that it stays
  within the existing weight boundaries <tt>[minWt,maxWt]</tt>.

\since v3.0


\subsection ch12s3s3_scale_weights 12.3.3 Scale All the Weigths of a Connection

Alternatively, it is possible to change the weights of all the synapses that belong to a certain connection ID
using CARLsim::scaleWeights:
\code
// must be in EXECUTION state
sim.runNetwork(1,0);

// remember connId from connect call
// multiply all allocated synapses of connId with scaling factor 1.345
// set updateWeightRange flag to true because it will be necessary to update [minWt,maxWt]
sim.scaleWeights(connId, 1.345f, false);
\endcode
This function will multiply the weight of every synapse of connection ID <tt>connId</tt> with a scaling factor
<tt>scale</tt>.
Here, the connection ID is the return argument of the corresponding CARLsim::connect call.
Also, neuron IDs should be zero-indexed, meaning that the first neuron in the group should have ID 0.

If the new weight (old weight times scaling factor) lies outside the boundaries <tt>[minWt,maxWt]</tt> of RangeWeight,
then two different behaviors can be achieved, depending on a third optional argument <tt>updateWeightRange</tt>.
- If <tt>updateWeightRange</tt> is set to <tt>true</tt>, then the corresponding weight boundaries <tt>[minWt,maxWt]</tt>
  will be updated should the new weight lie outside those boundaries.
- If <tt>updateWeightRange</tt> is set to <tt>false</tt>, then the corresponding weight will be clipped so that it stays
  within the existing weight boundaries <tt>[minWt,maxWt]</tt>.

\since v3.0



\section ch12s4_logging_errors 12.4 Logging and Errors
\TODO MB

Logger modes. Log files. User errors.


\section ch12s5_numerical_integration 12.5 Numerical Integration

Integration time step. Integration method. Weight update interval.


\section ch12s6_technical_limitations 12.6 Technical Limitations

Limitations on neuron/synapse/group/connection size, etc. Memory limitations (GPU memory). Max firing rate 520Hz. Handling large-scale networks.



*/